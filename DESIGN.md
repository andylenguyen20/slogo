### High Level Design Goals

From an objective point of view, the goal of this project is to create a programming environment that allows a user to draw turtles onto a screen and manipulate elements on the screen that can further manipulate data in the back-end. From a design perspective, we must do this using the Model-View-Controller infrastructure pattern. Essentially, we will have various screen components in our front end, which are part of our View. The View should render/display/format information from the Model that the user can see. The Model will hold this data and make changes to the data as needed. The Controller will facilitate the interactions between the View and the Model to ensure that they are well connected while maintaining good encapsulation between these two components. Another separate goal of the project involves flexibility: we must design a program that allows users to manipulate various different screen components that read from and write to any combination of Model components. In addition, we need to be able to make code that allows for further extension of functionality so that we can add new, cooler features to our programming environment with relative ease.


### Adding New Features

In order to add a new language that the commands can be written in, a user must add a new language properties file to resources.languages and then add that language choice to the LANGUAGE_LIST variable in the CommandBox class. 

In order to add a new turtle command or arithmetic command, a user must create a new class in the commandNode package that extends GeneralCommand. The user must then implement the evaluate() method within that class to match the functionality of the command. The parameter for evaluate will be the list of arguments that the command asks for, so the evaluate method would use arguments.get(argument position).getvalue() to get the numeric value of the argument. If the new command is a turtle command, the user must use a lambda function in conjunction with a call to model.update() in order to have the turtle command execute on all of the active turtles stored in model. Additionally, when a new command is added, the file numChildren.properties must be updated to reflect the number of arguments that the command has. 

In order to add a new view component to the front end, you must create a subclass of screen component and implement the generateGUIComponent and mapUserActions method. Then, you need to make a controller subclass that is specific to this view component and connect it to the Model/Controller in some way. To go a little in depth with this, you have the option to do two things: 1) If you want to have the gui component read information in the model and get notified when that information changes, you need to assign the view component as an observer of any model component and add the view component as an observer within that model component. 2) If you want your view component to be able to write to the model through user interaction of some sort, you can have the Controller subclass you just implemented implement an interface that you define and give to the view component. This interface will contain methods that can write to the model and these methods will then be available for the view component to use as needed.

### Major Design Choices

One major design decision we wanted to justify was the way we decided to break up the Controller component of this project. One issue that we ran into in the midst of the last sprint of this project was the fact that we initially had one main Controller object that initialized all view components on the screen and implemented many methods that these view components would call in order to read from/ write to the Model. The major design choice we decided to make was to break up the one Controller class into several individual Controller subclasses that were created based mostly off of view component. For instance, there would almost always be a one-to-one relationship between a ScreenComponent object and a Controller object. The main benefit of doing this was to avoid having main control; by this, I mean we could now avoid having one class that essentially has control over most of what is going on in the application. Instead, by splitting it up like this, we have separate controllers that are delegated separate responsibilities and functionality. There really wasnâ€™t much of a con of doing it this way. 

Another choice we made was to organize a list of commands as a tree which would execute them. The reason we decided to implement a tree is because some commands may have further children, and an initial command may not act on the immediate nodes following it. From there we had to decide how to evaluate these initial commands to build up to values which could be used when a final command is run. Using the amount of children inherent to a command we were able to create this tree, allowing certain nodes to have children based on the what the command represents (i.e. a fd node represents a forward command which needs one child). This allowed for us to easily represent the commands. From this representation we could then analyze the tree from the bottom up. We chose a tree over a stack because the idea of having multiple children is more easily represented in a tree, and values computed at a node would be re-accessible later in the run if necessary, while a stack would pop off this value, making it impossible for later use. A difficulty of using a tree, however, is that it can only go up when analyzing, so some nodes whose value may need to be changed when running a command higher up on the tree can not do so, representing only one value when computing others higher up in the tree. This limitation is very case-specific, so it did not affect really affect our project as a whole. 

### Assumptions

No major assumptions were made to simplify any ambiguities in this project.
